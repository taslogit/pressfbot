# Полный аудит логики приложения и запросов

**Дата:** 16.02.2025  
**Фокус:** запросы, начисление XP, стабильность, кэш профиля.

---

## 1. API-слой (utils/api.ts)

### 1.1 Retry и 429
- **429 не ретраится** — корректно (повтор при rate limit усугубляет нагрузку).
- Ретраи при 408, 5xx, TIMEOUT, NETWORK_ERROR с экспоненциальной задержкой (1s, 2s, 4s).
- В ответе при 429 проставляется `code: '429'` для обработки на UI.

### 1.2 Abort и таймаут
- Поддержка `options.signal` для отмены при unmount.
- Внутренний таймаут 30 с; при внешнем signal оба отменяются.
- При AbortError возвращается `{ ok: false, code: 'CANCELLED' }`.

### 1.3 Заголовки и сессия
- `getHeaders()` добавляет `Content-Type: application/json` и при наличии `X-Session-Id` из localStorage.
- Сессия читается из `lastmeme_session` в try/catch (без краша при недоступности storage).

**Рекомендация:** на бэкенде убедиться, что 429 возвращается с JSON `{ error: "...", code: "429" }`, чтобы фронт стабильно показывал сообщение и не путал с другими ошибками.

---

## 2. Начисление XP и кэш профиля

### 2.1 Источники XP (все проверены)

| Источник            | Где вызывается        | Обновление кэша до правок      | После правок                          |
|---------------------|------------------------|----------------------------------|----------------------------------------|
| Чекин               | Landing handleCheckIn  | Да (оптимистично)               | Без изменений                          |
| Ежедневный вход     | Landing useEffect      | Да                              | Без изменений                          |
| Гайд (guide reward) | Landing handleCloseGuide| Да                              | Без изменений                          |
| Ежедневные квесты   | DailyQuests handleClaim| Да                              | Без изменений                          |
| Создание письма     | CreateLetter handleSave| **Нет** — только refetch        | **Исправлено:** оптимистично в кэш     |
| Создание дуэли      | Duels handleSubmit     | **Нет** + двойной getUserProfileAsync | **Исправлено:** кэш + убран дубль |
| Покупка (XP)        | Store buyItem          | Только setProfile (state)       | **Исправлено:** сохранение в storage   |
| Mystery Box         | Store buyMysteryBox    | Не было                         | **Исправлено:** кэш при remainingXp    |

### 2.2 Критичные баги (исправлены)

1. **CreateLetter:** при получении `result.xp` вызывался только `getUserProfileAsync()` для расчёта уровня; кэш профиля не обновлялся → в Профиле/Магазине XP не обновлялся до следующего запроса.  
   **Исправление:** оптимистичное обновление `storage.saveUserProfile({ ...profile, experience: prevExp + result.xp })`, уровень считается по этому же значению без лишнего запроса.

2. **Duels:** два подряд вызова `getUserProfileAsync()` и отсутствие обновления кэша.  
   **Исправление:** один раз читаем кэш, считаем newExp, пишем в кэш и показываем уведомление; дублирующий запрос убран.

3. **Store (buyItem / buyMysteryBox):** после покупки обновлялся только state `profile`; при переходе на другой экран и обратно баланс мог браться из устаревшего кэша.  
   **Исправление:** при наличии `res.data.remainingXp` вызывается `storage.saveUserProfile({ ...cached, experience: res.data.remainingXp })`. Аналогично для Mystery Box.

4. **Profile:** после `profileAPI.get()` результат мержился в state, но не сохранялся в storage → кэш оставался старым.  
   **Исправление:** после мержа вызывается `storage.saveUserProfile(merged)`.

---

## 3. Профиль и настройки

### 3.1 Откуда читается профиль
- **Profile:** начальный state из `storage.getUserProfile()`, затем подтягивается `profileAPI.get()` и результат мержится и сохраняется в storage.
- **Store:** `profile` из `loadData()` (profileAPI.get); для отображения XP используется `profile?.spendableXp ?? profile?.experience`.
- **Landing:** для чекина/уведомлений используется кэш и оптимистичное обновление.

### 3.2 lastCheckIn
- Обновляется при успешном чекине из `result.data.timestamp` и сохраняется через `storage.updateSettings({ lastCheckIn: timestamp })`.
- Таймер и даты на главной считаются от этого значения.

### 3.3 Консистентность
- Все места, где начисляется XP или меняется баланс (покупка), теперь обновляют и state, и `storage` (кэш), чтобы Профиль и Магазин не показывали устаревшие данные.

---

## 4. Жизненный цикл запросов

### 4.1 Отмена при unmount
- **Store, Letters, Duels, Profile, CreateLetter:** используется `useApiAbort()` и передаётся `signal` в запросы.
- **Landing:** чекин, daily loot, guide — без signal (короткие запросы по действию пользователя); есть защита от двойного нажатия (isCheckInLoading).
- **Notifications, Squads, WitnessApproval, Search:** ранее добавлены isMountedRef и при необходимости useApiAbort.

### 4.2 Двойные запросы
- Устранён дубль `getUserProfileAsync` в Duels при создании дуэли с XP.
- Daily loot на главной отложен на 2.2 с, чтобы не совпадать с чекином и не провоцировать 429.

### 4.3 Очистка таймеров
- Landing: clearTimeout(dailyLootDelay), clearInterval(interval), clearInterval(beefInterval).
- Store: очистка таймеров 429 и фоновой ревалидации в cleanup useEffect.

---

## 5. Обработка ошибок

### 5.1 Чекин при 429
- Отдельное сообщение через `t('checkin_error_429')` и кнопка «Повторить».
- Кнопка черепа блокируется на время запроса (isCheckInLoading).

### 5.2 Глобальный баннер
- ApiErrorContext: показ ошибки и вызов последнего переданного retry (через ref).
- Landing, CreateLetter и др. вызывают `showApiError(msg, retry)` при сбоях API.

### 5.3 Локальные ошибки
- Store: catalogError, starsCatalogError, retry-таймеры при 429.
- Search: при ошибке сбрасываются letters/duels.

---

## 6. Рекомендации по бэкенду

1. **Чекин:** возвращать в теле ответа `timestamp` (мс) и `xp` при успешном начислении, чтобы фронт мог обновить lastCheckIn и кэш XP без дополнительного запроса.
2. **429:** по возможности возвращать JSON с полем `retryAfter` (секунды) и при необходимости отображать его в сообщении пользователю.
3. **Профиль:** если используется отдельное поле `spendableXp` (отличное от `experience`), в типах и на фронте стоит явно разделить их и при покупке обновлять в кэше оба поля, если бэкенд их отдаёт.

---

## 7. Итог правок в коде

- **CreateLetter.tsx:** при получении XP за письмо — оптимистичное обновление кэша профиля, расчёт уровня без лишнего getUserProfileAsync.
- **Duels.tsx:** при получении XP за дуэль — то же + удалён второй вызов getUserProfileAsync.
- **Profile.tsx:** после успешного profileAPI.get() — сохранение мерженного профиля в storage.
- **Store.tsx:** после buyItem и buyMysteryBox при наличии remainingXp — обновление кэша профиля (experience); добавлен импорт storage.

После этих изменений начисление XP и отображение баланса в приложении должны быть согласованы во всех сценариях (чекин, квесты, письма, дуэли, магазин).
